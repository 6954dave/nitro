import sys, os, glob

sys.path.append('../../build/scons')
import scons_utils
sys.path.pop()

################################################################################
# PROJECT SPECIFIC VARS/CODE
################################################################################
#==============================================================================#

LIB_NAME = '_nitropy'

# Handle command-line options
opts = scons_utils.add_default_options(Options())
opts.Add('swigify', 'run swig to generate the bindings', 0)
env = Environment(options = opts, ENV = os.environ)
Help(opts.GenerateHelpText(env))

# Get the target name, and setup all the system-dependent flags and libs
local_lib = scons_utils.do_configure(env)
print "Building for %s" % env['PLATFORM']
sourceFiles = scons_utils.get_source_files('./src/main/swig', ext='.c', platform=env['PLATFORM'])

depends = ['nitf-c']
include_path = ['../../c/nitf/include']
lib_path = ['../../c/nitf/%s' % local_lib]

PYTHON_DIR = 'src/main/python/nitf/'

#SCons knows that the .i suffix means to use swig to generate the source, and then compiles it... sweet!
if int(env.subst('$swigify')):
    #Here, we set the swig command-line args
    env['SWIGFLAGS'] = '-c -python %s -outdir %s' % \
            (' '.join(['-I%s' % p for p in include_path]), PYTHON_DIR)
    sourceFiles = glob.glob('src/main/swig/nitro.i')


#TODO - might need to fix this...
INCLUDE_POSSIBILITIES = [ os.path.join(os.path.dirname(sys.executable), 'include'),
    '/usr/include/python%s/' % sys.version.split()[0][0:3],]
for dir in INCLUDE_POSSIBILITIES:
    if os.path.isdir(dir):
        include_path.append(dir)

#TODO - might need to fix this...
LIB_POSSIBILITIES = [ os.path.join(os.path.dirname(sys.executable), 'libs'),
    '/usr/lib/python%s/' % sys.version.split()[0],]
for dir in LIB_POSSIBILITIES:
    if os.path.isdir(dir):
        lib_path.append(dir)


build_libs = [{'source':sourceFiles, 'lib':'%s' % LIB_NAME, 'depends':depends, 'dynamic':True},]

env.Append(CPPPATH = include_path)
#ignore mem leaks... only saw this with IOHandle, which is just an int
env.Append(CCFLAGS = ['-DNITF_MODULE_EXPORTS', '-DSWIG_PYTHON_SILENT_MEMLEAK'])

#make the lib(s)
libs = scons_utils.make_libs(env, build_libs, local_lib, lib_path)
pyExt = os.path.splitext(str(libs[0][0]))[1]
if 'win32' in env['PLATFORM']:
    pyExt = '.pyd'
env.InstallAs('%s/%s%s' % (PYTHON_DIR, LIB_NAME, pyExt), str(libs[0][0]))
#==============================================================================#
